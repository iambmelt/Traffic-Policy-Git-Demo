name: Create or Update ngrok Endpoint (deployment branch)

on:
  push:
    branches: [ deployment ]

permissions:
  contents: write
  pull-requests: write

env:
  NGROK_API_URL: https://api.ngrok.com/endpoints
  NGROK_API_VERSION: "2"

jobs:
  deploy:
    runs-on: ubuntu-latest
    # environment: production   # <- uncomment if you’re using an Environment secret

    steps:
      - name: Checkout (deployment branch)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure required files exist
        run: |
          set -e
          test -f config.yml || { echo "::error::Missing config.yml in branch"; exit 1; }

      - name: Detect policy file (policy.yml / policy.yaml / policy.json)
        id: policyfile
        shell: bash
        run: |
          set -euo pipefail
          declare -a found=()
          for f in policy.yml policy.yaml policy.json; do
            [[ -f "$f" ]] && found+=("$f")
          done

          if [[ ${#found[@]} -eq 0 ]]; then
            echo "::error::No policy file found. Add one of: policy.yml, policy.yaml, or policy.json"
            exit 1
          fi

          if [[ ${#found[@]} -gt 1 ]]; then
            echo "::error::Multiple policy files found: ${found[*]}. Keep exactly one."
            exit 1
          fi

          echo "Using policy file: ${found[0]}"
          echo "path=${found[0]}" >> "$GITHUB_OUTPUT"

      - name: Install tools (yq, jq)
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y -qq jq >/dev/null
          yq --version
          jq --version

      - name: Validate and read config.yml
        id: cfg
        shell: bash
        run: |
          set -euo pipefail

          # Required fields
          URL=$(yq -r '.url // ""'  config.yml)
          TYPE=$(yq -r '.type // ""' config.yml)

          if [[ -z "$URL" ]]; then
            echo "::error::config.yml is missing required key: url"
            exit 1
          fi
          if [[ -z "$TYPE" ]]; then
            echo "::error::config.yml is missing required key: type"
            exit 1
          fi

          # Optional fields
          DESC=$(yq -r '.description // ""' config.yml)
          META=$(yq -r '.metadata // ""'    config.yml)
          POOL=$(yq -r '(.pooling_enabled // "") | tostring' config.yml)
          CFG_ID=$(yq -r '.id // ""' config.yml)

          {
            echo "url<<__EOF__";  echo -n "$URL";  echo; echo "__EOF__"
            echo "type=$TYPE"
            echo "desc<<__EOF__"; echo -n "$DESC"; echo; echo "__EOF__"
            echo "meta<<__EOF__"; echo -n "$META"; echo; echo "__EOF__"
            echo "pool=$POOL"
            echo "cfg_id=$CFG_ID"
          } >> "$GITHUB_OUTPUT"

      - name: Build traffic policy JSON from detected file
        id: policy
        shell: bash
        run: |
          set -euo pipefail
          POLICY_SRC='${{ steps.policyfile.outputs.path }}'

          if [[ "$POLICY_SRC" == *.json ]]; then
            # Validate/compact JSON
            jq -c . "$POLICY_SRC" > /tmp/policy.json
          else
            # YAML -> JSON
            yq -o=json -I=0 '.' "$POLICY_SRC" > /tmp/policy.json
          fi

          # single line, no trailing newline
          tr -d '\n' < /tmp/policy.json > /tmp/policy.json.tmp && mv /tmp/policy.json.tmp /tmp/policy.json
          echo "path=/tmp/policy.json" >> "$GITHUB_OUTPUT"

      - name: Call ngrok API (create or update endpoint)
        id: api
        env:
          TOKEN: ${{ secrets.NGROK_API_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          echo "::add-mask::${TOKEN}"

          # Decide method, URL, expected status
          if [[ -n "${{ steps.cfg.outputs.cfg_id }}" ]]; then
            METHOD="PATCH"
            URL="${NGROK_API_URL}/${{ steps.cfg.outputs.cfg_id }}"
            CREATED="false"
            EXPECTED=200
            EXPECTED_LABEL="200 OK"
          else
            METHOD="POST"
            URL="${NGROK_API_URL}"
            CREATED="true"
            EXPECTED=201
            EXPECTED_LABEL="201 Created"
          fi

          # Build form data (omit type on PATCH)
          DATA=(
            --data-urlencode "url=${{ steps.cfg.outputs.url }}"
            --data-urlencode "traffic_policy@${{ steps.policy.outputs.path }}"
          )
          if [[ "${METHOD}" == "POST" ]]; then
            DATA+=( --data-urlencode "type=${{ steps.cfg.outputs.type }}" )
          fi
          if [[ -n "${{ steps.cfg.outputs.desc }}" ]]; then
            DATA+=( --data-urlencode "description=${{ steps.cfg.outputs.desc }}" )
          fi
          if [[ -n "${{ steps.cfg.outputs.meta }}" ]]; then
            DATA+=( --data-urlencode "metadata=${{ steps.cfg.outputs.meta }}" )
          fi
          if [[ -n "${{ steps.cfg.outputs.pool }}" ]]; then
            DATA+=( --data-urlencode "pooling_enabled=${{ steps.cfg.outputs.pool }}" )
          fi

          # Preview (token redacted)
          {
            echo "About to run this request (expecting ${EXPECTED_LABEL}):"
            printf "curl --request %s --location %q \\\n" "$METHOD" "$URL"
            printf "  --header %q \\\n" "Content-Type: application/x-www-form-urlencoded"
            printf "  --header %q \\\n" "Ngrok-Version: ${NGROK_API_VERSION}"
            printf "  --header %q \\\n" "Authorization: Bearer ***REDACTED***"
            for arg in "${DATA[@]}"; do printf "  %q \\\n" "$arg"; done
            echo "  --silent --show-error --write-out '%{http_code}'"
          } 1>&2

          # Execute
          HTTP_CODE=$(
            curl -sS -X "$METHOD" -w "%{http_code}" -o /tmp/resp.json \
              --location "$URL" \
              --header "Content-Type: application/x-www-form-urlencoded" \
              --header "Ngrok-Version: ${NGROK_API_VERSION}" \
              --header "Authorization: Bearer ${TOKEN}" \
              "${DATA[@]}"
          )

          echo "HTTP ${HTTP_CODE}"
          (jq -C . /tmp/resp.json || cat /tmp/resp.json)

          # Strict status check
          if [[ "${HTTP_CODE}" -ne "${EXPECTED}" ]]; then
            echo "::error::Unexpected status. Got ${HTTP_CODE}, expected ${EXPECTED_LABEL} for ${METHOD}."
            exit 1
          fi

          NEW_ID=$(jq -r '.id // empty' /tmp/resp.json)
          {
            echo "method=${METHOD}"
            echo "created=${CREATED}"
            echo "id=${NEW_ID}"
          } >> "$GITHUB_OUTPUT"

      - name: Prepare commit with new id on a branch from main
        id: commit
        if: steps.api.outputs.created == 'true' && steps.api.outputs.id != ''
        env:
          NEW_ID: ${{ steps.api.outputs.id }}
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin main

          BRANCH="add-endpoint-id-${NEW_ID}"
          git checkout -B "$BRANCH" origin/main

          # Put id at the very top of config.yml (remove any existing id if present)
          yq 'del(.id)' config.yml > /tmp/config.noid.yml || cp config.yml /tmp/config.noid.yml
          printf "id: %s\n" "$NEW_ID" > config.yml
          cat /tmp/config.noid.yml >> config.yml

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add config.yml
          git commit -m "chore: record ngrok endpoint id ${NEW_ID} in config.yml"
          git push -u origin "$BRANCH"

          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Open PR to main
        id: pr
        if: steps.api.outputs.created == 'true' && steps.api.outputs.id != ''
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          gh pr create \
            --base main \
            --head "${{ steps.commit.outputs.branch }}" \
            --title "chore: add ngrok endpoint id to config.yml" \
            --body "This PR adds the newly created ngrok endpoint id to the top of **config.yml**.<br />Generated automatically by the deployment workflow." \
            || echo "PR may already exist, continuing."

          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          HEAD="${OWNER}:${{ steps.commit.outputs.branch }}"
          PR_JSON=$(curl -sS -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${OWNER}/${REPO}/pulls?head=${HEAD}&state=open&per_page=1")
          PR_NUMBER=$(echo "$PR_JSON" | jq -r '.[0].number // empty')
          PR_URL=$(echo "$PR_JSON" | jq -r '.[0].html_url // empty')

          if [[ -z "$PR_NUMBER" ]]; then
            echo "::error::Could not determine PR number"; exit 1
          fi

          {
            echo "number=$PR_NUMBER"
            echo "url=$PR_URL"
          } >> "$GITHUB_OUTPUT"

      - name: Enable auto-merge (squash) or merge immediately
        if: steps.pr.outputs.number != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          if gh pr merge "${{ steps.pr.outputs.number }}" --squash --auto --delete-branch; then
            echo "Auto-merge enabled; PR will merge when checks pass."
          else
            echo "Auto-merge not available; attempting immediate squash merge…"
            gh pr merge "${{ steps.pr.outputs.number }}" --squash --delete-branch
          fi
