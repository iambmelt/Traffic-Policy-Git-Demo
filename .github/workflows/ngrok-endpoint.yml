# .github/workflows/ngrok-endpoint.yml
name: ngrok endpoint

on:
  workflow_call:
    inputs:
      config_path:
        description: "Path to the ngrok endpoint config file"
        required: false
        default: "config.yml"
        type: string
      policy_path:
        description: "Path or glob to the traffic policy; if empty, auto-detects policy.yml/.yaml/.json"
        required: false
        default: ""
        type: string
      base_branch:
        description: "Base branch to open PRs against when recording a new id"
        required: false
        default: "main"
        type: string
      ngrok_api_url:
        description: "Override the ngrok API base url for endpoints"
        required: false
        default: "https://api.ngrok.com/endpoints"
        type: string
      ngrok_api_version:
        description: "Ngrok-Version header value"
        required: false
        default: "2"
        type: string
      auto_merge:
        description: "Enable PR auto-merge when recording a new id"
        required: false
        default: false
        type: boolean
    secrets:
      NGROK_API_TOKEN:
        required: true

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      CONFIG_PATH: ${{ inputs.config_path }}
      POLICY_PATH: ${{ inputs.policy_path }}
      BASE_BRANCH: ${{ inputs.base_branch }}
      NGROK_API_URL: ${{ inputs.ngrok_api_url }}
      NGROK_API_VERSION: ${{ inputs.ngrok_api_version }}
      AUTO_MERGE: ${{ inputs.auto_merge }}

    steps:
      - uses: actions/checkout@v4

      - name: Install tools (yq, jq)
        run: |
          set -euo pipefail
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y -qq jq >/dev/null
          yq --version
          jq --version

      - name: Validate and read config
        id: cfg
        shell: bash
        run: |
          set -euo pipefail

          if [[ ! -f "$CONFIG_PATH" ]]; then
            echo "::error::Config not found at $CONFIG_PATH"
            exit 1
          fi

          # Normalize to JSON for easy extraction
          yq -o=json -I=0 '.' "$CONFIG_PATH" > /tmp/config.json

          # Required fields
          URL=$(jq -r '.url // empty' /tmp/config.json)
          TYPE=$(jq -r '.type // "cloud"' /tmp/config.json)
          if [[ -z "$URL" ]]; then
            echo "::error::Missing required field: url"
            exit 1
          fi

          # Optional fields
          ID=$(jq -r '.id // empty' /tmp/config.json)
          DESC=$(jq -r '.description // empty' /tmp/config.json)
          META=$(jq -c '.metadata // empty' /tmp/config.json)
          POOL=$(jq -r '.pooling_enabled // empty' /tmp/config.json)

          {
            echo "cfg_id=${ID}"
            echo "url=${URL}"
            echo "type=${TYPE}"
            echo "desc=${DESC}"
            echo "meta=${META}"
            echo "pool=${POOL}"
          } >> "$GITHUB_OUTPUT"

      - name: Find traffic policy file
        id: policyfile
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "$POLICY_PATH" ]]; then
            FILES=( $(compgen -G "$POLICY_PATH" || true) )
          else
            FILES=(policy.yml policy.yaml policy.json)
          fi

          CANDIDATES=()
          for f in "${FILES[@]}"; do
            [[ -f "$f" ]] && CANDIDATES+=("$f")
          done

          if [[ "${#CANDIDATES[@]}" -eq 0 ]]; then
            echo "::error::No traffic policy file found (looked for: $POLICY_PATH or policy.yml/.yaml/.json)"
            exit 1
          elif [[ "${#CANDIDATES[@]}" -gt 1 ]]; then
            echo "::error::Multiple traffic policy files detected: ${CANDIDATES[*]}"
            exit 1
          fi

          echo "path=${CANDIDATES[0]}" >> "$GITHUB_OUTPUT"

      - name: Build traffic policy JSON from detected file
        id: policy
        shell: bash
        run: |
          set -euo pipefail
          POLICY_SRC='${{ steps.policyfile.outputs.path }}'

          if [[ "$POLICY_SRC" == *.json ]]; then
            jq -c . "$POLICY_SRC" > /tmp/policy.json
          else
            yq -o=json -I=0 '.' "$POLICY_SRC" > /tmp/policy.json
          fi

          echo "path=/tmp/policy.json" >> "$GITHUB_OUTPUT"

      - name: Call ngrok API (create or update endpoint)
        id: api
        env:
          TOKEN: ${{ secrets.NGROK_API_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          echo "::add-mask::${TOKEN}"

          # Decide method, URL, expected status
          if [[ -n "${{ steps.cfg.outputs.cfg_id }}" ]]; then
            METHOD="PATCH"
            URL="${NGROK_API_URL}/${{ steps.cfg.outputs.cfg_id }}"
            CREATED="false"
            EXPECTED=200
          else
            METHOD="POST"
            URL="${NGROK_API_URL}"
            CREATED="true"
            EXPECTED=201
          fi

          # Build form data (omit type on PATCH)
          DATA=(
            --data-urlencode "url=${{ steps.cfg.outputs.url }}"
            --data-urlencode "traffic_policy@${{ steps.policy.outputs.path }}"
          )
          if [[ "${METHOD}" == "POST" ]]; then
            DATA+=( --data-urlencode "type=${{ steps.cfg.outputs.type }}" )
          fi
          if [[ -n "${{ steps.cfg.outputs.desc }}" ]]; then
            DATA+=( --data-urlencode "description=${{ steps.cfg.outputs.desc }}" )
          fi
          if [[ -n "${{ steps.cfg.outputs.meta }}" ]]; then
            DATA+=( --data-urlencode "metadata=${{ steps.cfg.outputs.meta }}" )
          fi
          # Only send boolean true/false; skip null/empty
          if [[ "${{ steps.cfg.outputs.pool }}" == "true" || "${{ steps.cfg.outputs.pool }}" == "false" ]]; then
            DATA+=( --data-urlencode "pooling_enabled=${{ steps.cfg.outputs.pool }}" )
          fi

          # Preview (token redacted)
          {
            echo "About to run this request (expecting HTTP ${EXPECTED}):"
            printf "curl --request %s --location %q \\\n" "$METHOD" "$URL"
            printf "  --header %q \\\n" "Content-Type: application/x-www-form-urlencoded"
            printf "  --header %q \\\n" "Ngrok-Version: ${NGROK_API_VERSION}"
            printf "  --header %q \\\n" "Authorization: Bearer ***REDACTED***"
            for arg in "${DATA[@]}"; do printf "  %q \\\n" "$arg"; done
            echo "  --silent --show-error --write-out '%{http_code}'"
          } 1>&2

          # Execute with retries
          HTTP_CODE=$(
            curl -sS -X "$METHOD" -w "%{http_code}" -o /tmp/resp.json \
              --retry 5 --retry-delay 2 --retry-connrefused \
              --location "$URL" \
              --header "Content-Type: application/x-www-form-urlencoded" \
              --header "Ngrok-Version: ${NGROK_API_VERSION}" \
              --header "Authorization: Bearer ${TOKEN}" \
              "${DATA[@]}"
          )

          echo "HTTP ${HTTP_CODE}"
          (jq -C . /tmp/resp.json || cat /tmp/resp.json)

          # Strict status check (with recovery for single-endpoint intent)
          if [[ "${HTTP_CODE}" -ne "${EXPECTED}" ]]; then
            # If we attempted to CREATE (POST) and got a 400 ERR_NGROK_18017,
            # recover by finding the existing endpoint for this URL and PATCHing it instead.
            # Tradeoff: we intentionally do NOT support option 2.B (pooling multiple endpoints on the same URL).
            # That means if the caller *intended* pooling, this recovery will keep a single endpoint and update it in-place.
            if [[ "${METHOD}" == "POST" && "${HTTP_CODE}" -eq 400 ]]; then
              ERR_CODE=$(jq -r '.error_code // empty' /tmp/resp.json || true)
              if [[ "${ERR_CODE}" == "ERR_NGROK_18017" ]]; then
                echo "Encountered ERR_NGROK_18017 (endpoint exists at URL without pooling). Attempting PATCH of existing endpoint…"
                TARGET_URL=${{ steps.cfg.outputs.url }}

                # Walk pages to find existing endpoint with this URL
                NEXT=""
                FOUND_ID=""
                while :; do
                  LIST_URL="${NGROK_API_URL}"
                  if [[ -n "${NEXT}" ]]; then
                    LIST_URL="${LIST_URL}?before_id=${NEXT}"
                  fi
                  LIST_CODE=$(
                    curl -sS -X GET -w "%{http_code}" -o /tmp/list.json \
                      --location "${LIST_URL}" \
                      --header "Ngrok-Version: ${NGROK_API_VERSION}" \
                      --header "Authorization: Bearer ${TOKEN}"
                  )
                  if [[ "${LIST_CODE}" -ne 200 ]]; then
                    echo "::error::Failed to list endpoints while recovering from ERR_NGROK_18017 (HTTP ${LIST_CODE})."
                    break
                  fi
                  FOUND_ID=$(jq -r --arg u "${TARGET_URL}" '.endpoints[]? | select(.url == $u) | .id' /tmp/list.json | head -n1 || true)
                  if [[ -n "${FOUND_ID}" ]]; then
                    break
                  fi
                  NEXT=$(jq -r '.next_id // empty' /tmp/list.json || true)
                  if [[ -z "${NEXT}" ]]; then
                    break
                  fi
                done

                if [[ -z "${FOUND_ID}" ]]; then
                  echo "::error::Could not find an existing endpoint for URL '${TARGET_URL}' to PATCH. Failing."
                  exit 1
                fi

                METHOD="PATCH"
                URL="${NGROK_API_URL}/${FOUND_ID}"
                CREATED="false"
                EXPECTED=200

                # Re-issue the request as PATCH with same DATA
                HTTP_CODE=$(
                  curl -sS -X "$METHOD" -w "%{http_code}" -o /tmp/resp.json \
                    --location "$URL" \
                    --header "Content-Type: application/x-www-form-urlencoded" \
                    --header "Ngrok-Version: ${NGROK_API_VERSION}" \
                    --header "Authorization: Bearer ${TOKEN}" \
                    "${DATA[@]}"
                )
                echo "HTTP ${HTTP_CODE} (after recovery PATCH)"
                (jq -C . /tmp/resp.json || cat /tmp/resp.json)

                if [[ "${HTTP_CODE}" -ne "${EXPECTED}" ]]; then
                  echo "::error::Recovery PATCH failed. Got ${HTTP_CODE}, expected HTTP ${EXPECTED}."
                  exit 1
                fi
              else
                echo "::error::Unexpected 4xx from create; not ERR_NGROK_18017. Failing."
                exit 1
              fi
            else
              echo "::error::Unexpected status. Got ${HTTP_CODE}, expected HTTP ${EXPECTED} for ${METHOD}."
              exit 1
            fi
          fi

          NEW_ID=$(jq -r '.id // empty' /tmp/resp.json)

          # Expose outputs for later steps
          {
            echo "method=${METHOD}"
            echo "created=${CREATED}"
            echo "id=${NEW_ID}"
          } >> "$GITHUB_OUTPUT"

      - name: Prepare commit with new id on a branch from base branch
        id: commit
        if: steps.api.outputs.created == 'true' && steps.api.outputs.id != ''
        env:
          NEW_ID: ${{ steps.api.outputs.id }}
        shell: bash
        run: |
          set -euo pipefail
          git fetch --quiet origin "$BASE_BRANCH" || { echo "::error::Base branch '${BASE_BRANCH}' not found"; exit 1; }

          BRANCH="add-endpoint-id-${NEW_ID}"
          git checkout -B "$BRANCH" "origin/${BASE_BRANCH}"

          # Put id at the very top of the config file (remove any existing id if present)
          yq 'del(.id)' "$CONFIG_PATH" > /tmp/config.noid.yml || cp "$CONFIG_PATH" /tmp/config.noid.yml
          printf "id: %s\n" "$NEW_ID" > "$CONFIG_PATH"
          cat /tmp/config.noid.yml >> "$CONFIG_PATH"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$CONFIG_PATH"
          git commit -m "chore: record new ngrok endpoint id ${NEW_ID}"

      - name: Open PR to base branch
        id: pr
        if: steps.commit.outcome == 'success'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh pr create --title "Record ngrok endpoint id ${NEW_ID}" \
            --body "Created by a GitHub Action. This PR writes the new endpoint id to ${CONFIG_PATH}." \
            --base "${BASE_BRANCH}" --head "$(git branch --show-current)" \
            --fill

      - name: Enable auto-merge (squash) or merge immediately
        if: steps.pr.outcome == 'success'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          if [[ "${AUTO_MERGE}" == "true" ]]; then
            gh pr merge "${{ steps.pr.outputs.number }}" --auto --squash --delete-branch
            echo "Auto-merge enabled; PR will merge when checks pass."
          else
            echo "Auto-merge not available; attempting immediate squash merge…"
            gh pr merge "${{ steps.pr.outputs.number }}" --squash --delete-branch
          fi

      - name: Upload debug artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ngrok-api-debug
          path: |
            /tmp/resp.json
            /tmp/policy.json
