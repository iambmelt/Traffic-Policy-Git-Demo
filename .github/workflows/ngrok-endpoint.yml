# .github/workflows/ngrok-endpoint.yml
name: ngrok endpoint

on:
  workflow_call:
    inputs:
      config_path:
        description: "Path to the ngrok endpoint config file"
        required: false
        default: "config.yml"
        type: string
      policy_path:
        description: "Path or glob to the traffic policy; if empty, auto-detects policy.yml/.yaml/.json"
        required: false
        default: ""
        type: string
      base_branch:
        description: "Base branch for PRs that record a new endpoint id"
        required: false
        default: "main"
        type: string
      ngrok_api_url:
        description: "Override ngrok API base URL"
        required: false
        default: "https://api.ngrok.com/endpoints"
        type: string
      ngrok_api_version:
        description: "Ngrok-Version header value"
        required: false
        default: "2"
        type: string
      auto_merge:
        description: "Enable auto-merge for the PR (squash); if false, skip merge step"
        required: false
        default: true
        type: boolean
    secrets:
      NGROK_API_TOKEN:
        required: true

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # Paths & branches (defaults preserved)
  CONFIG_PATH: ${{ inputs.config_path || 'config.yml' }}
  POLICY_PATH: ${{ inputs.policy_path || '' }}
  BASE_BRANCH: ${{ inputs.base_branch || 'main' }}

  # ngrok API knobs
  NGROK_API_URL: ${{ inputs.ngrok_api_url || 'https://api.ngrok.com/endpoints' }}
  NGROK_API_VERSION: ${{ inputs.ngrok_api_version || '2' }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (current ref)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure required files exist
        run: |
          set -euo pipefail
          test -f "$CONFIG_PATH" || { echo "::error::Missing $CONFIG_PATH"; exit 1; }

      - name: Detect policy file (honor policy_path input or auto-detect)
        id: policyfile
        shell: bash
        run: |
          set -euo pipefail

          # If caller specified POLICY_PATH, support exact path or glob
          if [[ -n "${POLICY_PATH}" ]]; then
            mapfile -t matches < <(compgen -G "${POLICY_PATH}" || true)
            if [[ ${#matches[@]} -eq 0 ]]; then
              echo "::error::policy_path '${POLICY_PATH}' matched no files"
              exit 1
            elif [[ ${#matches[@]} -gt 1 ]]; then
              echo "::error::policy_path '${POLICY_PATH}' matched multiple files: ${matches[*]}"
              exit 1
            fi
            echo "Using policy file from input: ${matches[0]}"
            echo "path=${matches[0]}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Otherwise, auto-detect (backwards-compatible)
          declare -a found=()
          for f in policy.yml policy.yaml policy.json; do
            [[ -f "$f" ]] && found+=("$f")
          done

          if [[ ${#found[@]} -eq 0 ]]; then
            echo "::error::No policy file found. Add one of: policy.yml, policy.yaml, or policy.json"
            exit 1
          fi

          if [[ ${#found[@]} -gt 1 ]]; then
            echo "::error::Multiple policy files found: ${found[*]}. Keep exactly one or set inputs.policy_path."
            exit 1
          fi

          echo "Using policy file: ${found[0]}"
          echo "path=${found[0]}" >> "$GITHUB_OUTPUT"

      - name: Install tools (yq, jq)
        run: |
          set -euo pipefail
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y -qq jq >/dev/null
          yq --version
          jq --version

      - name: Validate and read config
        id: cfg
        shell: bash
        run: |
          set -euo pipefail

          # Required fields
          URL=$(yq -r '.url // ""'  "$CONFIG_PATH")
          TYPE=$(yq -r '.type // ""' "$CONFIG_PATH")

          if [[ -z "$URL" ]]; then
            echo "::error::${CONFIG_PATH} is missing required key: url"
            exit 1
          fi
          if [[ -z "$TYPE" ]]; then
            echo "::error::${CONFIG_PATH} is missing required key: type"
            exit 1
          fi

          # Optional fields
          DESC=$(yq -r '.description // ""' "$CONFIG_PATH")
          META=$(yq -r '.metadata // ""'    "$CONFIG_PATH")
          # Keep as native boolean/null; don't coerce to string
          POOL=$(yq -r ' .pooling_enabled // null ' "$CONFIG_PATH")
          CFG_ID=$(yq -r '.id // ""' "$CONFIG_PATH")

          {
            echo "url<<__EOF__";  echo -n "$URL";  echo; echo "__EOF__"
            echo "type=$TYPE"
            echo "desc<<__EOF__"; echo -n "$DESC"; echo; echo "__EOF__"
            echo "meta<<__EOF__"; echo -n "$META"; echo; echo "__EOF__"
            echo "pool=$POOL"
            echo "cfg_id=$CFG_ID"
          } >> "$GITHUB_OUTPUT"

      - name: Build traffic policy JSON from detected file
        id: policy
        shell: bash
        run: |
          set -euo pipefail
          POLICY_SRC='${{ steps.policyfile.outputs.path }}'

          if [[ "$POLICY_SRC" == *.json ]]; then
            jq -c . "$POLICY_SRC" > /tmp/policy.json
          else
            yq -o=json -I=0 '.' "$POLICY_SRC" > /tmp/policy.json
          fi

          echo "path=/tmp/policy.json" >> "$GITHUB_OUTPUT"

      - name: Call ngrok API (create or update endpoint)
        id: api
        env:
          TOKEN: ${{ secrets.NGROK_API_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          echo "::add-mask::${TOKEN}"

          # Decide method, URL, expected status
          if [[ -n "${{ steps.cfg.outputs.cfg_id }}" ]]; then
            METHOD="PATCH"
            URL="${NGROK_API_URL}/${{ steps.cfg.outputs.cfg_id }}"
            CREATED="false"
            EXPECTED=200
            EXPECTED_LABEL="200 OK"
          else
            METHOD="POST"
            URL="${NGROK_API_URL}"
            CREATED="true"
            EXPECTED=201
            EXPECTED_LABEL="201 Created"
          fi

          # Build form data (omit type on PATCH)
          DATA=(
            --data-urlencode "url=${{ steps.cfg.outputs.url }}"
            --data-urlencode "traffic_policy@${{ steps.policy.outputs.path }}"
          )
          if [[ "${METHOD}" == "POST" ]]; then
            DATA+=( --data-urlencode "type=${{ steps.cfg.outputs.type }}" )
          fi
          if [[ -n "${{ steps.cfg.outputs.desc }}" ]]; then
            DATA+=( --data-urlencode "description=${{ steps.cfg.outputs.desc }}" )
          fi
          if [[ -n "${{ steps.cfg.outputs.meta }}" ]]; then
            DATA+=( --data-urlencode "metadata=${{ steps.cfg.outputs.meta }}" )
          fi
          # Only send boolean true/false; skip null/empty
          if [[ "${{ steps.cfg.outputs.pool }}" == "true" || "${{ steps.cfg.outputs.pool }}" == "false" ]]; then
            DATA+=( --data-urlencode "pooling_enabled=${{ steps.cfg.outputs.pool }}" )
          fi

          # Preview (token redacted)
          {
            echo "About to run this request (expecting ${EXPECTED_LABEL}):"
            printf "curl --request %s --location %q \\\n" "$METHOD" "$URL"
            printf "  --header %q \\\n" "Content-Type: application/x-www-form-urlencoded"
            printf "  --header %q \\\n" "Ngrok-Version: ${NGROK_API_VERSION}"
            printf "  --header %q \\\n" "Authorization: Bearer ***REDACTED***"
            for arg in "${DATA[@]}"; do printf "  %q \\\n" "$arg"; done
            echo "  --silent --show-error --write-out '%{http_code}'"
          } 1>&2

          # Execute with retries
          HTTP_CODE=$(
            curl -sS -X "$METHOD" -w "%{http_code}" -o /tmp/resp.json \
              --retry 5 --retry-delay 2 --retry-connrefused \
              --location "$URL" \
              --header "Content-Type: application/x-www-form-urlencoded" \
              --header "Ngrok-Version: ${NGROK_API_VERSION}" \
              --header "Authorization: Bearer ${TOKEN}" \
              "${DATA[@]}"
          )

          echo "HTTP ${HTTP_CODE}"
          (jq -C . /tmp/resp.json || cat /tmp/resp.json)

          # Strict status check
          if [[ "${HTTP_CODE}" -ne "${EXPECTED}" ]]; then
            echo "::error::Unexpected status. Got ${HTTP_CODE}, expected ${EXPECTED_LABEL} for ${METHOD}."
            exit 1
          fi

          NEW_ID=$(jq -r '.id // empty' /tmp/resp.json)

          # Expose outputs for later steps (incl. EXPECTED_LABEL for PR summary)
          {
            echo "method=${METHOD}"
            echo "created=${CREATED}"
            echo "id=${NEW_ID}"
            echo "expected_label=${EXPECTED_LABEL}"
          } >> "$GITHUB_OUTPUT"

      - name: Prepare commit with new id on a branch from base branch
        id: commit
        if: steps.api.outputs.created == 'true' && steps.api.outputs.id != ''
        env:
          NEW_ID: ${{ steps.api.outputs.id }}
        shell: bash
        run: |
          set -euo pipefail
          git fetch --quiet origin "$BASE_BRANCH" || { echo "::error::Base branch '${BASE_BRANCH}' not found"; exit 1; }

          BRANCH="add-endpoint-id-${NEW_ID}"
          git checkout -B "$BRANCH" "origin/${BASE_BRANCH}"

          # Put id at the very top of the config file (remove any existing id if present)
          yq 'del(.id)' "$CONFIG_PATH" > /tmp/config.noid.yml || cp "$CONFIG_PATH" /tmp/config.noid.yml
          printf "id: %s\n" "$NEW_ID" > "$CONFIG_PATH"
          cat /tmp/config.noid.yml >> "$CONFIG_PATH"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$CONFIG_PATH"
          git commit -m "chore: record ngrok endpoint id ${NEW_ID} in ${CONFIG_PATH}"
          git push -u origin "$BRANCH"

          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Open PR to base branch
        id: pr
        if: steps.api.outputs.created == 'true' && steps.api.outputs.id != ''
        env:
          GH_TOKEN: ${{ github.token }}
          METHOD: ${{ steps.api.outputs.method }}
          EXPECTED_LABEL: ${{ steps.api.outputs.expected_label }}
          NEW_ID: ${{ steps.api.outputs.id }}
        shell: bash
        run: |
          set -euo pipefail
          gh pr create \
            --base "${BASE_BRANCH}" \
            --head "${{ steps.commit.outputs.branch }}" \
            --title "chore: add ngrok endpoint id to ${CONFIG_PATH}" \
            --body "This PR adds the newly created ngrok endpoint id to the top of **${CONFIG_PATH}**.<br />Generated automatically by the deployment workflow." \
            || echo "PR may already exist or creation failed; attempting lookup"

          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          HEAD="${OWNER}:${{ steps.commit.outputs.branch }}"
          PR_JSON=$(curl -sS -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${OWNER}/${REPO}/pulls?head=${HEAD}&state=open&per_page=1" || true)
          PR_NUMBER=$(echo "$PR_JSON" | jq -r '.[0].number // empty')
          PR_URL=$(echo "$PR_JSON" | jq -r '.[0].html_url // empty')

          if [[ -z "$PR_NUMBER" ]]; then
            echo "::warning::No open PR found for head '${HEAD}'. Skipping merge step."
            exit 0
          fi

          {
            echo "number=$PR_NUMBER"
            echo "url=$PR_URL"
          } >> "$GITHUB_OUTPUT"

          {
            echo "### ngrok endpoint"
            echo "- Method: \`${METHOD}\`"
            echo "- Expected: ${EXPECTED_LABEL}"
            echo "- Endpoint ID: \`${NEW_ID:-n/a}\`"
            echo "- PR: ${PR_URL:-n/a}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Enable auto-merge (squash) or merge immediately
        if: steps.pr.outputs.number != '' && inputs.auto_merge
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          if gh pr merge "${{ steps.pr.outputs.number }}" --squash --auto --delete-branch; then
            echo "Auto-merge enabled; PR will merge when checks pass."
          else
            echo "Auto-merge not available; attempting immediate squash merge…"
            gh pr merge "${{ steps.pr.outputs.number }}" --squash --delete-branch
          fi

      - name: Upload debug artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ngrok-api-debug
          path: |
            /tmp/resp.json
            /tmp/policy.json
